// å‰ç«¯åº”ç”¨ä¸»é€»è¾‘ - å¯¹è§’çº¿å››åˆ†åŒºç‰ˆ
class EmotionCanvasApp {
    constructor() {
        this.canvas = document.getElementById('gridCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.avatarContainer = document.querySelector('.avatar-container');
        this.avatar = document.getElementById('avatar');
        this.currentMoodDisplay = document.getElementById('currentMood');
        this.stepCounterDisplay = document.getElementById('stepCounter');
        this.composingStatusDisplay = document.getElementById('composingStatus');
        this.recordingStatusDisplay = document.getElementById('recordingStatus');
        this.playPauseBtn = document.getElementById('playPauseBtn');
        this.saveBtn = document.getElementById('saveBtn');
        this.audioPlayer = document.getElementById('audioPlayer');

        // åº”ç”¨çŠ¶æ€
        this.currentMood = null;
        this.isComposing = false;
        this.isRecording = false;
        this.stepCounter = 0;
        this.sessionId = null;
        this.moodConfig = {};
        this.scales = {};
        this.activeHighlights = new Map();
        this.recorder = null;
        this.audioChunks = [];
        this.recordedAudio = null;

        // å¤´åƒå¼¹æ€§æ‹‰åŠ¨çŠ¶æ€
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.avatarOffsetX = 0;
        this.avatarOffsetY = 0;
        this.maxPullDistance = 100; // æœ€å¤§æ‹‰åŠ¨è·ç¦»

        // edefzdc0 (1584/72=22, 864/72=12)
        this.gridWidth = 22;
        this.gridHeight = 12;
        this.cellSize = 72;
        this.avatarFaces = {
            base: './assets/face.png',
            happy: './assets/happy_face.png',
            calm: './assets/clam_face.png',
            tense: './assets/tense_face.png',
            sad: './assets/sad_face.png'
        };

        // åˆå§‹åŒ–éŸ³é¢‘
        this.initAudio();
        this.init();
    }

    initAudio() {
        // ä½¿ç”¨æ›´çœŸå®çš„é’¢ç´éŸ³è‰²
        this.synth = new Tone.PolySynth({
            maxPolyphony: 32,
            voice: Tone.Synth,
            options: {
                oscillator: {
                    type: "triangle8"
                },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 1.2
                },
                filter: {
                    Q: 8,
                    frequency: 1200,
                    type: "lowpass"
                }
            }
        });

        // åˆ›å»ºæ•ˆæœé“¾
        this.reverb = new Tone.Reverb({
            decay: 2.8,
            wet: 0.25
        });

        this.delay = new Tone.FeedbackDelay({
            delayTime: 0.15,
            feedback: 0.4,
            wet: 0.1
        });

        this.compressor = new Tone.Compressor({
            threshold: -24,
            ratio: 4,
            attack: 0.003,
            release: 0.25
        });

        this.eq = new Tone.EQ3({
            low: -2,
            mid: 0,
            high: 2
        });

        // è¿æ¥æ•ˆæœé“¾
        this.synth.chain(
            this.compressor,
            this.eq,
            this.delay,
            this.reverb,
            Tone.Destination
        );

        console.log('ğŸ¹ é«˜çº§é’¢ç´éŸ³è‰²åˆå§‹åŒ–å®Œæˆ');
    }

    async initRecorder() {
        try {
            // å°è¯•è·å–å±å¹•éŸ³é¢‘æµï¼ˆéœ€è¦æµè§ˆå™¨æ”¯æŒï¼‰
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                throw new Error('æµè§ˆå™¨ä¸æ”¯æŒå±å¹•å½•åˆ¶');
            }

            // è·å–å±å¹•å…±äº«æµï¼ˆåŒ…å«éŸ³é¢‘ï¼‰
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: true,
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: 44100,
                    channelCount: 2
                }
            });

            // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡æ¥å¤„ç†éŸ³é¢‘
            const audioContext = new AudioContext();
            const source = audioContext.createMediaStreamSource(stream);
            const destination = audioContext.createMediaStreamDestination();

            // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
            source.connect(destination);

            // åˆ›å»ºå½•éŸ³å™¨
            this.recorder = new MediaRecorder(destination.stream);
            this.recorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };

            this.recorder.onstop = () => {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                this.recordedAudio = audioBlob;
                this.audioPlayer.src = URL.createObjectURL(audioBlob);
                this.saveBtn.disabled = false;
                
                // åœæ­¢æ‰€æœ‰éŸ³è½¨
                stream.getTracks().forEach(track => track.stop());
                console.log('ğŸ™ï¸ å±å¹•å½•éŸ³å®Œæˆ');
            };

            return true;
        } catch (error) {
            console.error('æ— æ³•è®¿é—®å±å¹•éŸ³é¢‘:', error);
            
            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ç³»ç»ŸéŸ³é¢‘ï¼ˆéœ€è¦ç”¨æˆ·æˆæƒï¼‰
            try {
                const fallbackStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100,
                        channelCount: 2
                    }
                });

                this.recorder = new MediaRecorder(fallbackStream);
                this.recorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    }
                };

                this.recorder.onstop = () => {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                    this.recordedAudio = audioBlob;
                    this.audioPlayer.src = URL.createObjectURL(audioBlob);
                    this.saveBtn.disabled = false;
                    console.log('ğŸ™ï¸ ç³»ç»ŸéŸ³é¢‘å½•éŸ³å®Œæˆ');
                };

                return true;
            } catch (fallbackError) {
                console.error('ä¹Ÿæ— æ³•è®¿é—®ç³»ç»ŸéŸ³é¢‘:', fallbackError);
                alert('æ— æ³•è®¿é—®éŸ³é¢‘è¾“å…¥è®¾å¤‡ï¼Œå½•éŸ³åŠŸèƒ½ä¸å¯ç”¨');
                return false;
            }
        }
    }

    async init() {
        await this.initBackend();
        this.setupEventListeners();
        this.drawGrid();
        
        // å¯åŠ¨éŸ³é¢‘
        await Tone.start();
        console.log('ğŸµ éŸ³é¢‘ä¸Šä¸‹æ–‡å·²å¯åŠ¨');
    }

    async initBackend() {
        try {
            const moodsResponse = await fetch('/moods');
            this.moodConfig = await moodsResponse.json();
            console.log('æƒ…ç»ªé…ç½®:', this.moodConfig);

            for (const mood in this.moodConfig) {
                const scaleName = this.moodConfig[mood].scale;
                const scaleResponse = await fetch(`/scale?name=${scaleName}`);
                this.scales[mood] = await scaleResponse.json();
            }

            const sessionResponse = await fetch('/sessions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    grid_width: this.gridWidth,
                    grid_height: this.gridHeight
                })
            });

            const sessionData = await sessionResponse.json();
            this.sessionId = sessionData.session_id;

        } catch (error) {
            console.error('åˆå§‹åŒ–åç«¯å¤±è´¥ï¼Œä½¿ç”¨é™çº§é…ç½®:', error);
            this.useFallbackConfig();
        }
    }

    useFallbackConfig() {
        // ä¼˜åŒ–çš„éŸ³ä¹é…ç½®
        this.moodConfig = {
            happy: {
                bpm: 120,
                step: 1,
                scale: "C_major",
                vel: [70, 85],
                legato: 0.7
            },
            calm: {
                bpm: 80,
                step: 2,
                scale: "G_major",
                vel: [50, 65],
                legato: 1.2
            },
            tense: {
                bpm: 100,
                step: 1,
                scale: "E_minor",
                vel: [60, 75],
                legato: 0.5
            },
            sad: {
                bpm: 70,
                step: 2,
                scale: "A_minor",
                vel: [45, 60],
                legato: 1.0
            }
        };

        // å’Œè°çš„éŸ³é˜¶å®šä¹‰
        this.scales = {
            happy: {
                notes: [60, 62, 64, 65, 67, 69, 71, 72], // Cå¤§è°ƒ
                type: "major"
            },
            calm: {
                notes: [55, 57, 59, 60, 62, 64, 66, 67], // Gå¤§è°ƒ
                type: "major"
            },
            tense: {
                notes: [52, 54, 55, 57, 59, 60, 62, 64], // Eå°è°ƒ
                type: "minor"
            },
            sad: {
                notes: [57, 59, 60, 62, 64, 65, 67, 69], // Aå°è°ƒ
                type: "minor"
            }
        };

        this.sessionId = 'fallback-session-' + Date.now();
        console.log('ğŸµ ä½¿ç”¨ä¼˜åŒ–é™çº§é…ç½®æˆåŠŸ');
    }

    setupEventListeners() {
        // ç”»å¸ƒäº‹ä»¶
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.handleMouseMove(e.touches[0]);
        });
        this.canvas.addEventListener('touchend', () => this.handleMouseLeave());

        // å¤´åƒå¼¹æ€§æ‹–æ‹½äº‹ä»¶
        this.setupAvatarDrag();

        // æ§ä»¶äº‹ä»¶
        this.playPauseBtn.addEventListener('click', () => this.toggleComposing());
        this.saveBtn.addEventListener('click', () => this.saveAudio());

        console.log('ğŸ® äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆ');
    }

    setupAvatarDrag() {
        // é¼ æ ‡äº‹ä»¶
        this.avatarContainer.addEventListener('mousedown', (e) => this.startDrag(e));
        document.addEventListener('mousemove', (e) => this.drag(e));
        document.addEventListener('mouseup', () => this.stopDrag());

        // è§¦æ‘¸äº‹ä»¶
        this.avatarContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.startDrag(e.touches[0]);
        });
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.drag(e.touches[0]);
        });
        document.addEventListener('touchend', () => this.stopDrag());
    }

    startDrag(e) {
        this.isDragging = true;
        this.dragStartX = e.clientX;
        this.dragStartY = e.clientY;
        this.avatarOffsetX = 0;
        this.avatarOffsetY = 0;
        this.avatarContainer.classList.add('dragging');
        
        // æ›´æ–°å…‰æ ‡æ ·å¼
        document.body.style.cursor = 'grabbing';
    }

    drag(e) {
        if (!this.isDragging) return;

        const deltaX = e.clientX - this.dragStartX;
        const deltaY = e.clientY - this.dragStartY;

        // è®¡ç®—è·ç¦»ä¸­å¿ƒçš„è·ç¦»
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // å¼¹æ€§æ•ˆæœï¼šè·ç¦»è¶Šè¿œï¼Œé˜»åŠ›è¶Šå¤§
        if (distance > this.maxPullDistance) {
            const angle = Math.atan2(deltaY, deltaX);
            this.avatarOffsetX = Math.cos(angle) * this.maxPullDistance;
            this.avatarOffsetY = Math.sin(angle) * this.maxPullDistance;
        } else {
            this.avatarOffsetX = deltaX;
            this.avatarOffsetY = deltaY;
        }

        // åº”ç”¨å¼¹æ€§ä½ç½®
        this.avatarContainer.style.transform = `translate(calc(-50% + ${this.avatarOffsetX}px), calc(-50% + ${this.avatarOffsetY}px))`;
    }

    stopDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.avatarContainer.classList.remove('dragging');
        document.body.style.cursor = '';

        // å¼¹æ€§å›å¼¹åŠ¨ç”»
        gsap.to(this.avatarContainer, {
            x: 0,
            y: 0,
            duration: 0.6,
            ease: "elastic.out(1, 0.5)",
            onUpdate: () => {
                this.avatarContainer.style.transform = `translate(calc(-50% + ${this.avatarContainer._gsap.x}px), calc(-50% + ${this.avatarContainer._gsap.y}px))`;
            }
        });

        console.log('ğŸ‘¤ å¤´åƒå¼¹æ€§å›å¼¹');
    }

    getCurrentRegion(x, y) {
        // å°†åæ ‡è½¬æ¢ä¸ºç›¸å¯¹ä½ç½® (0-1)
        const relX = x / this.canvas.width;
        const relY = y / this.canvas.height;

        console.log(`åæ ‡: (${relX.toFixed(2)}, ${relY.toFixed(2)})`);

        // æ£€æµ‹é¼ æ ‡åœ¨å“ªä¸ªæƒ…ç»ªåŒºåŸŸ
        for (const [mood, condition] of Object.entries(this.regions)) {
            if (condition(relX, relY)) {
                console.log(`æ£€æµ‹åˆ°æƒ…ç»ªåŒºåŸŸ: ${mood}`);
                return mood;
            }
        }

        console.log('æœªæ£€æµ‹åˆ°æƒ…ç»ªåŒºåŸŸ');
        return null;
    }

    updateRegionIndicator(mood) {
        document.querySelectorAll('.region-label').forEach(label => {
            const baseSrc = label.getAttribute('data-src-default');
            if (baseSrc) {
                label.src = baseSrc;
            }
            label.classList.remove('active');
        });

        if (mood) {
            const activeLabel = document.querySelector(`.${mood}-region`);
            if (activeLabel) {
                const hoverSrc = activeLabel.getAttribute('data-src-active');
                if (hoverSrc) {
                    activeLabel.src = hoverSrc;
                }
                activeLabel.classList.add('active');
            }
        }
    }

    setMood(mood) {
        if (this.currentMood === mood) return;

        this.currentMood = mood;
        this.currentMoodDisplay.textContent = `Current mood: ${this.getMoodText(mood)}`;
        this.setAvatarFace(mood);
        
        // æ›´æ–°å¤´åƒå®¹å™¨æ ·å¼
        this.avatarContainer.className = 'avatar-container ' + mood;
        this.updateRegionIndicator(mood);

        console.log(`ğŸµ è¿›å…¥æƒ…ç»ªåŒºåŸŸ: ${mood}`);
    }

    setAvatarFace(mood) {
        const face = this.avatarFaces[mood] || this.avatarFaces.base;
        this.avatar.src = face;
    }

    getMoodText(mood) {
        const texts = {
            happy: 'Happy',
            calm: 'Calm', 
            tense: 'Tense',
            sad: 'Sad'
        };
        return texts[mood] || mood;
    }

    async toggleComposing() {
        if (!this.isComposing) {
            await this.startComposing();
        } else {
            this.stopComposing();
        }
    }

    async startComposing() {
        // åˆå§‹åŒ–å½•éŸ³å™¨
        const recorderReady = await this.initRecorder();
        if (!recorderReady) {
            alert('å½•éŸ³åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•å¼€å§‹æ¢ç´¢');
            return;
        }

        this.isComposing = true;
        Tone.Transport.start();
        
        // è‡ªåŠ¨å¼€å§‹å½•éŸ³
        this.startRecording();
        
        this.playPauseBtn.textContent = '';
        this.playPauseBtn.classList.add('playing');
        this.composingStatusDisplay.textContent = 'Status: Exploring';

        console.log('ğŸµ å¼€å§‹æ¢ç´¢ + è‡ªåŠ¨å½•éŸ³');
    }

    stopComposing() {
        this.isComposing = false;
        Tone.Transport.stop();
        
        // è‡ªåŠ¨åœæ­¢å½•éŸ³
        this.stopRecording();
        
        this.playPauseBtn.textContent = '';
        this.playPauseBtn.classList.remove('playing');
        this.composingStatusDisplay.textContent = 'Status: Stopped';
        this.updateRegionIndicator(null);
        this.currentMoodDisplay.textContent = 'Current mood: Awaiting exploration';

        console.log('â¹ï¸ åœæ­¢æ¢ç´¢ + å½•éŸ³');
    }

    startRecording() {
        if (!this.recorder) {
            console.warn('å½•éŸ³åŠŸèƒ½ä¸å¯ç”¨');
            return;
        }

        this.audioChunks = [];
        this.recorder.start();
        this.isRecording = true;
        this.recordingStatusDisplay.textContent = 'Recording: Recording';
        this.saveBtn.disabled = true;

        console.log('ğŸ™ï¸ è‡ªåŠ¨å¼€å§‹å½•éŸ³');
    }

    stopRecording() {
        if (this.recorder && this.isRecording) {
            this.recorder.stop();
            this.isRecording = false;
            this.recordingStatusDisplay.textContent = 'Recording: Stopped';
            console.log('â¹ï¸ è‡ªåŠ¨åœæ­¢å½•éŸ³');
        }
    }

    handleMouseMove(e) {
        if (!this.isComposing) return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const currentRegion = this.getCurrentRegion(x, y);
        if (currentRegion && currentRegion !== this.currentMood) {
            this.setMood(currentRegion);
        }

        const cellX = Math.floor(x / this.cellSize);
        const cellY = Math.floor(y / this.cellSize);

        if (cellX >= 0 && cellX < this.gridWidth && cellY >= 0 && cellY < this.gridHeight && this.currentMood) {
            this.createHighlight(cellX, cellY);
            this.triggerNote(cellX, cellY);
            this.sendCellToBackend(cellX, cellY);
        }
    }

    handleMouseLeave() {
        this.updateRegionIndicator(null);
        this.currentMoodDisplay.textContent = 'Current mood: Awaiting exploration';
        this.setAvatarFace('base');
    }

    createHighlight(x, y) {
        const cellKey = `${x},${y}`;
        if (this.activeHighlights.has(cellKey)) {
            const existingHighlight = this.activeHighlights.get(cellKey);
            existingHighlight.remove();
            this.activeHighlights.delete(cellKey);
        }

        const highlight = document.createElement('div');
        highlight.className = `grid-highlight ${this.currentMood}`;
        highlight.style.width = `${this.cellSize}px`;
        highlight.style.height = `${this.cellSize}px`;
        highlight.style.left = `${x * this.cellSize}px`;
        highlight.style.top = `${y * this.cellSize}px`;
        highlight.style.opacity = '1';

        // Special layered effect for happy
        if (this.currentMood === 'happy') {
            const baseImg = document.createElement('img');
            baseImg.src = './assets/grid_happy.png';
            baseImg.alt = 'happy grid base';
            baseImg.className = 'happy-base';
            const overlayImg = document.createElement('img');
            overlayImg.src = './assets/grid_happy_ex.png';
            overlayImg.alt = 'happy grid overlay';
            overlayImg.className = 'happy-overlay';

            highlight.appendChild(baseImg);
            highlight.appendChild(overlayImg);

            setTimeout(() => {
                baseImg.style.opacity = '0';
            }, 100);

            setTimeout(() => {
                overlayImg.classList.add('dissolve');
            }, 700);
        }

        document.querySelector('.canvas-container').appendChild(highlight);

        setTimeout(() => {
            highlight.style.opacity = '0';
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.parentNode.removeChild(highlight);
                }
                this.activeHighlights.delete(cellKey);
            }, 1500);
        }, 100);

        this.activeHighlights.set(cellKey, highlight);
    }

    async triggerNote(x, y) {
        if (!this.moodConfig[this.currentMood] || !this.isComposing) return;

        const cfg = this.moodConfig[this.currentMood];
        const scale = this.scales[this.currentMood];
        if (!scale || !scale.notes) return;

        this.stepCounter++;
        this.stepCounterDisplay.textContent = `Notes: ${this.stepCounter}`;

        if (this.stepCounter % cfg.step === 0) {
            const mainPitch = this.getHarmonicPitch(x, y, scale);
            const velocity = this.mapIntensityToVelocity(1.0, cfg.vel);
            const duration = this.calculateNoteDuration(cfg.legato, cfg.bpm);

            this.synth.triggerAttackRelease(
                Tone.Frequency(mainPitch, "midi").toFrequency(),
                duration,
                Tone.now(),
                velocity / 127
            );

            this.playHarmonicChord(mainPitch, scale, cfg, duration, velocity);
        }
    }

    getHarmonicPitch(x, y, scale) {
        const rowNote = Math.floor((y / this.gridHeight) * 3);
        const colNote = Math.floor((x / this.gridWidth) * scale.notes.length);
        
        const baseOctave = Math.floor(rowNote);
        const noteIndex = colNote % scale.notes.length;
        
        let basePitch = scale.notes[noteIndex];
        basePitch += baseOctave * 12;
        
        return Math.max(48, Math.min(76, basePitch));
    }

    playHarmonicChord(rootPitch, scale, cfg, duration, velocity) {
        let chordIntervals;
        if (scale.type === "major") {
            chordIntervals = [0, 4, 7]; // å¤§ä¸‰å’Œå¼¦
        } else {
            chordIntervals = [0, 3, 7]; // å°ä¸‰å’Œå¼¦
        }

        if (Math.random() < 0.3) {
            chordIntervals.forEach((interval, index) => {
                const chordPitch = rootPitch + interval;
                if (chordPitch <= 76) {
                    const chordTime = Tone.now() + 0.05 + (index * 0.02);
                    const chordVelocity = velocity * (0.3 + (index * 0.15));
                    
                    this.synth.triggerAttackRelease(
                        Tone.Frequency(chordPitch, "midi").toFrequency(),
                        duration * 0.6,
                        chordTime,
                        chordVelocity / 127
                    );
                }
            });
        }
    }

    mapIntensityToVelocity(intensity, velRange) {
        const [min, max] = velRange;
        const randomVariation = (Math.random() - 0.5) * 8;
        return Math.floor(min + intensity * (max - min) + randomVariation);
    }

    calculateNoteDuration(legato, bpm) {
        const beatDuration = 60.0 / bpm;
        const randomVariation = 1 + (Math.random() - 0.5) * 0.03;
        return beatDuration * legato * randomVariation;
    }

    async sendCellToBackend(x, y) {
        if (!this.sessionId) return;

        try {
            const cellData = {
                x: x,
                y: y,
                emotion: this.currentMood,
                intensity: 1.0,
                timestamp: new Date().toISOString()
            };

            await fetch(`/sessions/${this.sessionId}/cells`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(cellData)
            });

        } catch (error) {
            console.error('å‘é€æ ¼å­æ•°æ®å¤±è´¥:', error);
        }
    }

    saveAudio() {
        if (!this.recordedAudio) {
            alert('æ²¡æœ‰å¯ä¿å­˜çš„å½•éŸ³');
            return;
        }

        const url = URL.createObjectURL(this.recordedAudio);
        const a = document.createElement('a');
        a.href = url;
        a.download = `æƒ…ç»ªéŸ³ä¹_${this.formatDate(new Date())}.wav`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('ğŸ’¾ éŸ³é¢‘å·²ä¿å­˜');
        this.showSaveNotification();
    }

    formatDate(date) {
        return date.toISOString()
            .replace(/[:.]/g, '-')
            .replace('T', '_')
            .slice(0, 19);
    }

    showSaveNotification() {
        const existingNotification = document.querySelector('.save-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        const notification = document.createElement('div');
        notification.className = 'save-notification';
        notification.textContent = 'ğŸµ éŸ³é¢‘å·²ä¿å­˜åˆ°æœ¬åœ°ï¼';

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    drawGrid() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawGridLines();
    }

    drawGridLines() {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        this.ctx.lineWidth = 1;

        for (let x = 0; x <= this.gridWidth; x++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x * this.cellSize, 0);
            this.ctx.lineTo(x * this.cellSize, this.canvas.height);
            this.ctx.stroke();
        }

        for (let y = 0; y <= this.gridHeight; y++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y * this.cellSize);
            this.ctx.lineTo(this.canvas.width, y * this.cellSize);
            this.ctx.stroke();
        }
    }
}

// å¯åŠ¨åº”ç”¨
document.addEventListener('DOMContentLoaded', () => {
    try {
        window.app = new EmotionCanvasApp();
        console.log('ğŸ‰ æƒ…ç»ªéŸ³ä¹ç”»å¸ƒåº”ç”¨å¯åŠ¨æˆåŠŸï¼');
    } catch (error) {
        console.error('åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
        alert('åº”ç”¨å¯åŠ¨å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
    }
});














